
<div align=center>
<h1> 布局方法整理与总结
</div>

<br/>

<h2> 1. Auto layout

<h4> 1.1 布局原理

Auto layout布局分成两个部分，一是添加约束,二是根据约束计算frame.
<br/>用约束来描述布局，通过Cassowary解析约束规则,取得布局的frame.Cassowary是一种数学算法，应用到编程上，将布局问题抽象成线性方程组求解。

<h4> 1.2 Auto layout 性能

Auto layout相比手动布局多的时间分为两部分，一是添加约束的时间，二是通过约束计算出frame的时间。

<h4> 1.3 intrinsicContentSize的说明

intrinsicContentSize 指UIView根据自己的内容确定的size。
重写了这个方法的控件只设置origin就可以确定自身的frame。例如UILabel, UIImageView. UIButton重写了这个方法,因而实际应用中，只需要操作origin就可以确定位置。

相关文档:<br/>
Custom views typically have content that they display of which the layout system is unaware. Setting this property allows a custom view to communicate to the layout system what size it would like to be based on its content. This intrinsic size must be independent of the content frame, because there’s no way to dynamically communicate a changed width to the layout system based on a changed height, for example.

<h4> 1.4 Content Compression Resistance Priority 和 Content Hugging Priority的说明

Content Compression Resistance Priority: 抗压缩的优先级；<br/>
Content Hugging Priority: 抗拉伸的优先级；<br/><br/>
首先View需要有intrinsicContentSize，才会有压缩，拉伸的概念,拉伸压缩优先级才有意义。

<pre>
<code>
//抗拉伸的优先级
- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);
//抗压缩的优先级
- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);
</code>
</pre>

ps:<br/>一开始有在想拉伸和压缩不是对立面吗，如果一个View抗压缩级别高，抗拉伸级别高，会怎样？压缩和拉伸是两种互斥的状态，并不是中文意义上的动作。考虑横轴方向，当View的frame.width小于intrinsicContentSize.width,即为压缩状态，反之即为拉伸状态。

###### 压缩状态只关系抗压缩的优先级，与抗拉伸的优先级无关。<br/>拉伸状态只关系抗拉伸的优先级，与抗压缩的优先级无关。

<h4> 1.5 Masonry 编程方式

采用的是链式编程的方式, Auto Layout写起来比较复杂，下面是创建一个约束的方法,代码还是比较复杂的。

<pre>
<code>
+ (instancetype)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c;
</code>
</pre>

###### Masonry使用了链式编程方式去简化代码解决这个问题,将方法返回值设置成实例或者返回值为实例的block来实现链式方式。

<pre>
<code>
- (MASConstraint * (^)(CGFloat))offset {
    return ^id(CGFloat offset){
        self.offset = offset;
        return self;
    };
}

- (MASConstraint * (^)(id))equalTo {
    return ^id(id attribute) {
        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);
    };
}
</code>
</pre>
<pre>
<code>
[label mas_makeConstraints:^(MASConstraintMaker *make) {
    make.centerY.mas_equalTo(self.view.mas_centerY);
    make.left.equalTo(self.view.mas_left).with.offset(20);
    make.right.equalTo(label2.mas_left).with.offset(-20);
}];
</code>
</pre>

Masonry对Constraint进行了管理，封装了设置，更新和重设三种方法。通过这三种方法去管理MASViewConstraint约束的设置和更新。
<pre>
<code>
- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;

- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;

- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block
</code>
</pre>

MASViewConstraint封装了设置NSLayoutConstraint所需要的所有元素，在自身install的时候设置Auto Layout的NSLayoutConstraint，完成Auto Layout的布局。

<h2> 2. 手动布局

具有最高的灵活性，也是最简单明确的，但是同时也存在难维护和可读性差的问题。

<h2> 3. ASDK布局

<!-- <div align=center>
![css 盒模型](./texturelogo.svg)
<br/>
<br/>
</div> -->


AsyncDisplayKit现在已经更名为[Texture](https://github.com/texturegroup/texture)。Texture中的ASDisplayNode是对UIView的一个抽象，并拥有很多针对其他元素的抽象和封装，如下图：
<br/>
<div align=center>
![](./nodehierarchy.png)
<br/>
<br/>
</div>

<br/>
Texture将布局与node分离出来，封装成一个布局类ASLayoutSpec。先初始化node，再重载下面的方法去布局node。

<pre>
<code>
/**
 * @abstract Return a layout spec that describes the layout of the receiver and its children.
 *
 * @param constrainedSize The minimum and maximum sizes the receiver should fit in.
 *
 * @discussion Subclasses that override should expect this method to be called on a non-main thread. The returned layout spec
 * is used to calculate an ASLayout and cached by ASDisplayNode for quick access during -layout. Other expensive work that needs to
 * be done before display can be performed here, and using ivars to cache any valuable intermediate results is
 * encouraged.
 *
 * @note This method should not be called directly outside of ASDisplayNode; use -layoutThatFits: instead.
 *
 * @warning Subclasses that implement -layoutSpecThatFits: must not use .layoutSpecBlock. Doing so will trigger an
 * exception. A future version of the framework may support using both, calling them serially, with the .layoutSpecBlock
 * superseding any values set by the method override.
 */
- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constrainedSize;
</code>
</pre>

如果想调用view时，可以直接通过node.view或者node.layer的方式来直接使用view或者layer,但需要在主线程中调用，UI操作在子线程调用时不会当即变化。
<br/>
有些需要注意的地方，AsyncDisplayKit的sample的podfile在使用时需要加上use_frameworks!来框架化,否则会找不到AsyncDisplayKit framework。Texture是基于CSS FlexBox模式来布局,但是并[没有实现](http://texturegroup.org/docs/layout2-web-flexbox-differences.html)全部FlexBox属性。

Texture是异步去做图片解码，计算文字size，渲染以及其它一些耗时UI操作。

Texture的智能预加载
ASDisplayNode存在一个protected属性Interface State，
<pre>
<code>
typedef NS_OPTIONS(NSUInteger, ASInterfaceState)
{
  /** The element is not predicted to be onscreen soon and preloading should not be performed */
  ASInterfaceStateNone          = 0,
  /** The element may be added to a view soon that could become visible.  Measure the layout, including size calculation. */
  ASInterfaceStateMeasureLayout = 1 << 0,
  /** The element is likely enough to come onscreen that disk and/or network data required for display should be fetched. */
  ASInterfaceStatePreload       = 1 << 1,
  /** The element is very likely to become visible, and concurrent rendering should be executed for any -setNeedsDisplay. */
  ASInterfaceStateDisplay       = 1 << 2,
  /** The element is physically onscreen by at least 1 pixel.
   In practice, all other bit fields should also be set when this flag is set. */
  ASInterfaceStateVisible       = 1 << 3,

  /**
   * The node is not contained in a cell but it is in a window.
   *
   * Currently we only set `interfaceState` to other values for
   * nodes contained in table views or collection views.
   */
  ASInterfaceStateInHierarchy   = ASInterfaceStateMeasureLayout | ASInterfaceStatePreload | ASInterfaceStateDisplay | ASInterfaceStateVisible,
};
</code>
</pre>
页面滑动时会更新node的ASInterfaceState,通过下面的方法根据Interface State变化来渲染view。滑动方向上Preload区域比另一个方向上的Preload区域要大很多，这是对滑动机制的一个优化。

Visible Range:
<pre>
<code>
-didEnterVisibleState
-didExitVisibleState
</code>
</pre>

Display Range:
<pre>
<code>
-didEnterDisplayState
-didExitDisplayState
</code>
</pre>

Preload Range:
<pre>
<code>
-didEnterPreloadState
-didExitPreloadState
</code>
</pre>

<div align=center>
![预加载](./asdk_Preload2.png)
<br/><br/>
</div>

[官方文档](http://texturegroup.org/docs/layout2-quickstart.html)提及的优点：

Fast: As fast as manual layout code and significantly faster than Auto Layout
<br/>
Asynchronous & Concurrent: Layouts can be computed on background threads so user interactions are not interrupted.
<br/>
Declarative: Layouts are declared with immutable data structures. This makes layout code easier to develop, document, code review, test, debug, profile, and maintain.
<br/>
Cacheable: Layout results are immutable data structures so they can be precomputed in the background and cached to increase user perceived performance.
<br/>
Extensible: Easy to share code between classes.

但是也是存在缺点，异步布局会产生一些UI的展示延迟，对文本等控件差距并不明显，对于image就很明显。因而在使用时需要考虑应用场景。

<h2> 4. Flex 布局

Yoga本是Facebook在React Native里引入的一种跨平台的基于CSS的布局引擎，它实现了Flexbox规范，完全遵守W3C的规范。随着该系统不断完善，Facebook对其进行重新发布，于是就成了现在的Yoga。Weex和React Native的布局都是基于Yoga的布局。

2009年，W3C提出了一种新的方案——Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了几乎所有浏览器的支持，目前的前端主要是使用Html / CSS / JS实现，其中CSS用于前端的布局。

Flexbox布局（Flexible Box)设计之初的目的是为了能更加高效的分配子视图的布局情况，包括动态的改变宽度，高度，以及排列顺序。Flexbox可以更加方便的兼容各个大小不同的屏幕，比如拉伸和压缩子视图。W3C官方称为[CSS弹性盒子布局](https://www.w3.org/TR/css-flexbox-1/)。

<!-- <div align=center>
![css 盒模型](./flexbox_model.png)
<br/><br/>主轴水平方向上的css 盒模型
</div> -->

flexbox 布局原理
主要是子元素的布局计算，因为最大容器window的size是一定的，根据容器size布局子元素，确定子元素的size。之后再递归布局子元素容器。**这里以主轴为横轴举例**,子元素的size由width,height,flex-grow,flex-shrink,flex-basis确定。优先级：flex-grow,flex-shrink > flex-basis > width,height。<br/>
flex-grow是指item的扩张性的能力，值越大扩张性越大；<br/>
flex-shrink是指item的抗收缩性的能力，值越大越不容易收缩；<br/>
flex-basis是item的size标准值，会覆盖width，height；<br/><br/>
**如果item没有设置flex-basis以及height，item的高度就是容器的height。**

<h2> 5.布局方式的性能

Auto Layout性能是最低的，

Texture也就是AsyncDisplayKit，和Yoga都是利用flexbox布局来实现的。但是Texture将耗时的布局过程放在子线程去做。
manual性能是最高的。

<h2> References：

第一篇：[这个](https://github.com/ming1016/study/wiki/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Auto-Layout%EF%BC%8C%E5%88%86%E6%9E%90iOS%E5%90%84%E7%89%88%E6%9C%AC%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7)
<br/>第二篇：[这个](http://draveness.me/layout-performance.html)
<br/>第三篇：[还有这个](http://www.open-open.com/lib/view/open1491392446525.html)

第二篇文章存在的问题
<br/>一是Auto layout测试代码中多了优先级的布局代码。测量时间不准确，去掉之后测量时间不是文章说的手动布局的16倍，而是6倍。
<br/>二是测量的时间并不准确，只是测量出添加约束的时间。
